// base IIFE to define idiomorph
var Idiomorph = (function () {
    "use strict";

    let EMPTY_SET = new Set();

    let defaults = {
        morphStyle: "outerHTML",
        callbacks: {
            beforeNodeAdded: noOp,
            afterNodeAdded: noOp,
            beforeNodeMorphed: noOp,
            afterNodeMorphed: noOp,
            beforeNodeRemoved: noOp,
            afterNodeRemoved: noOp,
            beforeAttributeUpdated: noOp,
        },
        head: {
            style: "merge",
            shouldPreserve: function (elt) {
                return elt.getAttribute("im-preserve") === "true";
            },
            shouldReAppend: function (elt) {
                return elt.getAttribute("im-re-append") === "true";
            },
            shouldRemove: noOp,
            afterHeadMorphed: noOp,
        },
    };

    function morph(oldNode, newContent, config = {}) {
        if (oldNode instanceof Document) {
            oldNode = oldNode.documentElement;
        }

        if (typeof newContent === "string") {
            newContent = parseContent(newContent);
        }

        let normalizedContent = normalizeContent(newContent);

        let ctx = createMorphContext(oldNode, normalizedContent, config);

        return morphNormalizedContent(oldNode, normalizedContent, ctx);
    }

    function morphNormalizedContent(oldNode, normalizedNewContent, ctx) {
        if (ctx.head.block) {
            let oldHead = oldNode.querySelector("head");
            let newHead = normalizedNewContent.querySelector("head");
            if (oldHead && newHead) {
                let promises = handleHeadElement(newHead, oldHead, ctx);
                Promise.all(promises).then(function () {
                    morphNormalizedContent(
                        oldNode,
                        normalizedNewContent,
                        Object.assign(ctx, {
                            head: {
                                block: false,
                                ignore: true,
                            },
                        })
                    );
                });
                return;
            }
        }

        if (ctx.morphStyle === "innerHTML") {
            morphChildren(normalizedNewContent, oldNode, ctx);
            return oldNode.children;
        } else if (ctx.morphStyle === "outerHTML" || ctx.morphStyle == null) {
            let bestMatch = findBestNodeMatch(
                normalizedNewContent,
                oldNode,
                ctx
            );
            let previousSibling = bestMatch?.previousSibling;
            let nextSibling = bestMatch?.nextSibling;
            let morphedNode = morphOldNodeTo(oldNode, bestMatch, ctx);

            if (bestMatch) {
                return insertSiblings(
                    previousSibling,
                    morphedNode,
                    nextSibling
                );
            } else {
                return [];
            }
        } else {
            throw "Do not understand how to morph style " + ctx.morphStyle;
        }
    }

    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
        return (
            ctx.ignoreActiveValue &&
            possibleActiveElement === document.activeElement
        );
    }

    function morphOldNodeTo(oldNode, newContent, ctx) {
        if (ctx.ignoreActive && oldNode === document.activeElement) {
        } else if (newContent == null) {
            if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
                return oldNode;
            oldNode.remove();
            ctx.callbacks.afterNodeRemoved(oldNode);
            return null;
        } else if (!isSoftMatch(oldNode, newContent)) {
            if (ctx.callbacks.beforeNodeRemoved(oldNode) === false)
                return oldNode;
            if (ctx.callbacks.beforeNodeAdded(newContent) === false)
                return oldNode;
            oldNode.parentElement.replaceChild(newContent, oldNode);
            ctx.callbacks.afterNodeAdded(newContent);
            ctx.callbacks.afterNodeRemoved(oldNode);
            return newContent;
        } else {
            if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false)
                return oldNode;
            if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {
            } else if (
                oldNode instanceof HTMLHeadElement &&
                ctx.head.style !== "morph"
            ) {
                handleHeadElement(newContent, oldNode, ctx);
            } else {
                syncNodeFrom(newContent, oldNode, ctx);
                if (!ignoreValueOfActiveElement(oldNode, ctx)) {
                    morphChildren(newContent, oldNode, ctx);
                }
            }
            ctx.callbacks.afterNodeMorphed(oldNode, newContent);
            return oldNode;
        }
    }

    function morphChildren(newParent, oldParent, ctx) {
        let nextNewChild = newParent.firstChild;
        let insertionPoint = oldParent.firstChild;
        let newChild;
        while (nextNewChild) {
            newChild = nextNewChild;
            nextNewChild = newChild.nextSibling;
            if (insertionPoint == null) {
                if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
                oldParent.appendChild(newChild);
                ctx.callbacks.afterNodeAdded(newChild);
                removeIdsFromConsideration(ctx, newChild);
                continue;
            }
            if (isIdSetMatch(newChild, insertionPoint, ctx)) {
                morphOldNodeTo(insertionPoint, newChild, ctx);
                insertionPoint = insertionPoint.nextSibling;
                removeIdsFromConsideration(ctx, newChild);
                continue;
            }
            let idSetMatch = findIdSetMatch(
                newParent,
                oldParent,
                newChild,
                insertionPoint,
                ctx
            );
            if (idSetMatch) {
                insertionPoint = removeNodesBetween(
                    insertionPoint,
                    idSetMatch,
                    ctx
                );
                morphOldNodeTo(idSetMatch, newChild, ctx);
                removeIdsFromConsideration(ctx, newChild);
                continue;
            }
            let softMatch = findSoftMatch(
                newParent,
                oldParent,
                newChild,
                insertionPoint,
                ctx
            );
            if (softMatch) {
                insertionPoint = removeNodesBetween(
                    insertionPoint,
                    softMatch,
                    ctx
                );
                morphOldNodeTo(softMatch, newChild, ctx);
                removeIdsFromConsideration(ctx, newChild);
                continue;
            }
            if (ctx.callbacks.beforeNodeAdded(newChild) === false) return;
            oldParent.insertBefore(newChild, insertionPoint);
            ctx.callbacks.afterNodeAdded(newChild);
            removeIdsFromConsideration(ctx, newChild);
        }
        while (insertionPoint !== null) {
            let tempNode = insertionPoint;
            insertionPoint = insertionPoint.nextSibling;
            removeNode(tempNode, ctx);
        }
    }

    function ignoreAttribute(attr, to, updateType, ctx) {
        if (
            attr === "value" &&
            ctx.ignoreActiveValue &&
            to === document.activeElement
        ) {
            return true;
        }
        return (
            ctx.callbacks.beforeAttributeUpdated(attr, to, updateType) === false
        );
    }

    function syncNodeFrom(from, to, ctx) {
        let type = from.nodeType;
        if (type === 1) {
            const fromAttributes = from.attributes;
            const toAttributes = to.attributes;
            for (const fromAttribute of fromAttributes) {
                if (ignoreAttribute(fromAttribute.name, to, "update", ctx)) {
                    continue;
                }
                if (
                    to.getAttribute(fromAttribute.name) !== fromAttribute.value
                ) {
                    to.setAttribute(fromAttribute.name, fromAttribute.value);
                }
            }
            for (let i = toAttributes.length - 1; 0 <= i; i--) {
                const toAttribute = toAttributes[i];
                if (ignoreAttribute(toAttribute.name, to, "remove", ctx)) {
                    continue;
                }
                if (!from.hasAttribute(toAttribute.name)) {
                    to.removeAttribute(toAttribute.name);
                }
            }
        }
        if (type === 8 || type === 3) {
            if (to.nodeValue !== from.nodeValue) {
                to.nodeValue = from.nodeValue;
            }
        }
        if (!ignoreValueOfActiveElement(to, ctx)) {
            syncInputValue(from, to, ctx);
        }
    }

    function syncBooleanAttribute(from, to, attributeName, ctx) {
        if (from[attributeName] !== to[attributeName]) {
            let ignoreUpdate = ignoreAttribute(
                attributeName,
                to,
                "update",
                ctx
            );
            if (!ignoreUpdate) {
                to[attributeName] = from[attributeName];
            }
            if (from[attributeName]) {
                if (!ignoreUpdate) {
                    to.setAttribute(attributeName, from[attributeName]);
                }
            } else {
                if (!ignoreAttribute(attributeName, to, "remove", ctx)) {
                    to.removeAttribute(attributeName);
                }
            }
        }
    }

    function syncInputValue(from, to, ctx) {
        if (
            from instanceof HTMLInputElement &&
            to instanceof HTMLInputElement &&
            from.type !== "file"
        ) {
            let fromValue = from.value;
            let toValue = to.value;
            syncBooleanAttribute(from, to, "checked", ctx);
            syncBooleanAttribute(from, to, "disabled", ctx);
            if (!from.hasAttribute("value")) {
                if (!ignoreAttribute("value", to, "remove", ctx)) {
                    to.value = "";
                    to.removeAttribute("value");
                }
            } else if (fromValue !== toValue) {
                if (!ignoreAttribute("value", to, "update", ctx)) {
                    to.setAttribute("value", fromValue);
                    to.value = fromValue;
                }
            }
        } else if (from instanceof HTMLOptionElement) {
            syncBooleanAttribute(from, to, "selected", ctx);
        } else if (
            from instanceof HTMLTextAreaElement &&
            to instanceof HTMLTextAreaElement
        ) {
            let fromValue = from.value;
            let toValue = to.value;
            if (ignoreAttribute("value", to, "update", ctx)) {
                return;
            }
            if (fromValue !== toValue) {
                to.value = fromValue;
            }
            if (to.firstChild && to.firstChild.nodeValue !== fromValue) {
                to.firstChild.nodeValue = fromValue;
            }
        }
    }

    function handleHeadElement(newHeadTag, currentHead, ctx) {
        let added = [];
        let removed = [];
        let preserved = [];
        let nodesToAppend = [];
        let headMergeStyle = ctx.head.style;
        let srcToNewHeadNodes = new Map();
        for (const newHeadChild of newHeadTag.children) {
            srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
        }
        for (const currentHeadElt of currentHead.children) {
            let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
            let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
            let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
            if (inNewContent || isPreserved) {
                if (isReAppended) {
                    removed.push(currentHeadElt);
                } else {
                    srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
                    preserved.push(currentHeadElt);
                }
            } else {
                if (headMergeStyle === "append") {
                    if (isReAppended) {
                        removed.push(currentHeadElt);
                        nodesToAppend.push(currentHeadElt);
                    }
                } else {
                    if (ctx.head.shouldRemove(currentHeadElt) !== false) {
                        removed.push(currentHeadElt);
                    }
                }
            }
        }
        nodesToAppend.push(...srcToNewHeadNodes.values());
        let promises = [];
        for (const newNode of nodesToAppend) {
            let newElt = document
                .createRange()
                .createContextualFragment(newNode.outerHTML).firstChild;
            if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
                if (newElt.href || newElt.src) {
                    let resolve = null;
                    let promise = new Promise(function (_resolve) {
                        resolve = _resolve;
                    });
                    newElt.addEventListener("load", function () {
                        resolve();
                    });
                    promises.push(promise);
                }
                currentHead.appendChild(newElt);
                ctx.callbacks.afterNodeAdded(newElt);
                added.push(newElt);
            }
        }
        for (const removedElement of removed) {
            if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
                currentHead.removeChild(removedElement);
                ctx.callbacks.afterNodeRemoved(removedElement);
            }
        }
        ctx.head.afterHeadMorphed(currentHead, {
            added: added,
            kept: preserved,
            removed: removed,
        });
        return promises;
    }

    function noOp() {}

    function mergeDefaults(config) {
        let finalConfig = {};
        Object.assign(finalConfig, defaults);
        Object.assign(finalConfig, config);
        finalConfig.callbacks = {};
        Object.assign(finalConfig.callbacks, defaults.callbacks);
        Object.assign(finalConfig.callbacks, config.callbacks);
        finalConfig.head = {};
        Object.assign(finalConfig.head, defaults.head);
        Object.assign(finalConfig.head, config.head);
        return finalConfig;
    }

    function createMorphContext(oldNode, newContent, config) {
        config = mergeDefaults(config);
        return {
            target: oldNode,
            newContent: newContent,
            config: config,
            morphStyle: config.morphStyle,
            ignoreActive: config.ignoreActive,
            ignoreActiveValue: config.ignoreActiveValue,
            idMap: createIdMap(oldNode, newContent),
            deadIds: new Set(),
            callbacks: config.callbacks,
            head: config.head,
        };
    }

    function isIdSetMatch(node1, node2, ctx) {
        if (node1 == null || node2 == null) return false;
        if (
            node1.nodeType === node2.nodeType &&
            node1.tagName === node2.tagName
        ) {
            if (node1.id !== "" && node1.id === node2.id) {
                return true;
            } else {
                return getIdIntersectionCount(ctx, node1, node2) > 0;
            }
        }
        return false;
    }

    function isSoftMatch(node1, node2) {
        if (node1 == null || node2 == null) return false;
        return (
            node1.nodeType === node2.nodeType && node1.tagName === node2.tagName
        );
    }

    function removeNodesBetween(startInclusive, endExclusive, ctx) {
        while (startInclusive !== endExclusive) {
            let tempNode = startInclusive;
            startInclusive = startInclusive.nextSibling;
            removeNode(tempNode, ctx);
        }
        removeIdsFromConsideration(ctx, endExclusive);
        return endExclusive.nextSibling;
    }

    function findIdSetMatch(
        newContent,
        oldParent,
        newChild,
        insertionPoint,
        ctx
    ) {
        let newChildPotentialIdCount = getIdIntersectionCount(
            ctx,
            newChild,
            oldParent
        );
        let potentialMatch = null;
        if (newChildPotentialIdCount > 0) {
            let potentialMatch = insertionPoint;
            let otherMatchCount = 0;
            while (potentialMatch != null) {
                if (isIdSetMatch(newChild, potentialMatch, ctx)) {
                    return potentialMatch;
                }
                otherMatchCount += getIdIntersectionCount(
                    ctx,
                    potentialMatch,
                    newContent
                );
                if (otherMatchCount > newChildPotentialIdCount) {
                    return null;
                }
                potentialMatch = potentialMatch.nextSibling;
            }
        }
        return potentialMatch;
    }

    function findSoftMatch(
        newContent,
        oldParent,
        newChild,
        insertionPoint,
        ctx
    ) {
        let potentialSoftMatch = insertionPoint;
        let nextSibling = newChild.nextSibling;
        let siblingSoftMatchCount = 0;

        while (potentialSoftMatch != null) {
            if (
                getIdIntersectionCount(ctx, potentialSoftMatch, newContent) > 0
            ) {
                return null;
            }
            if (isSoftMatch(newChild, potentialSoftMatch)) {
                return potentialSoftMatch;
            }
            if (isSoftMatch(nextSibling, potentialSoftMatch)) {
                siblingSoftMatchCount++;
                nextSibling = nextSibling.nextSibling;
                if (siblingSoftMatchCount >= 2) {
                    return null;
                }
            }
            potentialSoftMatch = potentialSoftMatch.nextSibling;
        }
        return potentialSoftMatch;
    }

    function parseContent(newContent) {
        let parser = new DOMParser();
        let contentWithSvgsRemoved = newContent.replace(
            /<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim,
            ""
        );
        if (
            contentWithSvgsRemoved.match(/<\/html>/) ||
            contentWithSvgsRemoved.match(/<\/head>/) ||
            contentWithSvgsRemoved.match(/<\/body>/)
        ) {
            let content = parser.parseFromString(newContent, "text/html");
            if (contentWithSvgsRemoved.match(/<\/html>/)) {
                content.generatedByIdiomorph = true;
                return content;
            } else {
                let htmlElement = content.firstChild;
                if (htmlElement) {
                    htmlElement.generatedByIdiomorph = true;
                    return htmlElement;
                } else {
                    return null;
                }
            }
        } else {
            let responseDoc = parser.parseFromString(
                "<body><template>" + newContent + "</template></body>",
                "text/html"
            );
            let content = responseDoc.body.querySelector("template").content;
            content.generatedByIdiomorph = true;
            return content;
        }
    }

    function normalizeContent(newContent) {
        if (newContent == null) {
            const dummyParent = document.createElement("div");
            return dummyParent;
        } else if (newContent.generatedByIdiomorph) {
            return newContent;
        } else if (newContent instanceof Node) {
            const dummyParent = document.createElement("div");
            dummyParent.append(newContent);
            return dummyParent;
        } else {
            const dummyParent = document.createElement("div");
            for (const elt of [...newContent]) {
                dummyParent.append(elt);
            }
            return dummyParent;
        }
    }

    function insertSiblings(previousSibling, morphedNode, nextSibling) {
        let stack = [];
        let added = [];
        while (previousSibling != null) {
            stack.push(previousSibling);
            previousSibling = previousSibling.previousSibling;
        }
        while (stack.length > 0) {
            let node = stack.pop();
            added.push(node);
            morphedNode.parentElement.insertBefore(node, morphedNode);
        }
        added.push(morphedNode);
        while (nextSibling != null) {
            stack.push(nextSibling);
            added.push(nextSibling);
            nextSibling = nextSibling.nextSibling;
        }
        while (stack.length > 0) {
            morphedNode.parentElement.insertBefore(
                stack.pop(),
                morphedNode.nextSibling
            );
        }
        return added;
    }

    function findBestNodeMatch(newContent, oldNode, ctx) {
        let currentElement;
        currentElement = newContent.firstChild;
        let bestElement = currentElement;
        let score = 0;
        while (currentElement) {
            let newScore = scoreElement(currentElement, oldNode, ctx);
            if (newScore > score) {
                bestElement = currentElement;
                score = newScore;
            }
            currentElement = currentElement.nextSibling;
        }
        return bestElement;
    }

    function scoreElement(node1, node2, ctx) {
        if (isSoftMatch(node1, node2)) {
            return 0.5 + getIdIntersectionCount(ctx, node1, node2);
        }
        return 0;
    }

    function removeNode(tempNode, ctx) {
        removeIdsFromConsideration(ctx, tempNode);
        if (ctx.callbacks.beforeNodeRemoved(tempNode) === false) return;
        tempNode.remove();
        ctx.callbacks.afterNodeRemoved(tempNode);
    }

    function isIdInConsideration(ctx, id) {
        return !ctx.deadIds.has(id);
    }

    function idIsWithinNode(ctx, id, targetNode) {
        let idSet = ctx.idMap.get(targetNode) || EMPTY_SET;
        return idSet.has(id);
    }

    function removeIdsFromConsideration(ctx, node) {
        let idSet = ctx.idMap.get(node) || EMPTY_SET;
        for (const id of idSet) {
            ctx.deadIds.add(id);
        }
    }

    function getIdIntersectionCount(ctx, node1, node2) {
        let sourceSet = ctx.idMap.get(node1) || EMPTY_SET;
        let matchCount = 0;
        for (const id of sourceSet) {
            if (
                isIdInConsideration(ctx, id) &&
                idIsWithinNode(ctx, id, node2)
            ) {
                ++matchCount;
            }
        }
        return matchCount;
    }

    function createIdMap(node, content) {
        let idMap = new Map();
        populateIdMap(node, idMap);
        populateIdMap(content, idMap);
        return idMap;
    }

    function populateIdMap(node, idMap) {
        let nodeParent = node;
        let idSet = new Set();
        Array.from(nodeParent.querySelectorAll("[id]")).forEach(function (elt) {
            let id = elt.id;
            if (idSet.has(id)) {
                console.warn("Found duplicate id: " + id);
            } else {
                idSet.add(id);
            }
        });
        if (nodeParent.id) {
            idSet.add(nodeParent.id);
        }
        idMap.set(nodeParent, idSet);
        for (const child of node.children) {
            populateIdMap(child, idMap);
            for (const id of idMap.get(child)) {
                idMap.get(nodeParent).add(id);
            }
        }
    }

    return {
        morph,
        defaults,
    };
})();

/**
 * Azumi Live - Client Runtime
 *
 * Features:
 * - Event delegation for az-on attributes
 * - DOM morphing via Idiomorph
 * - Optimistic UI via data-predict attributes (Azumi Live)
 */
class Azumi {
    constructor() {
        this.scopes = new WeakMap(); // Element -> state cache
        this.delegate();
    }

    // Event delegation
    delegate() {
        ["click", "submit", "change", "input"].forEach((event) => {
            document.addEventListener(event, (e) => this.handleEvent(e));
        });
    }

    // Parse az-on attribute
    handleEvent(e) {
        const target = e.target.closest(`[az-on]`);
        if (!target) return;

        // Check if the event type matches the trigger (e.g. "click ...")
        // Simple parsing: "click call foo" or "submit call bar"
        const attr = target.getAttribute("az-on");
        const parts = attr.split(" ");
        const trigger = parts[0];

        if (trigger !== e.type) return;

        e.preventDefault(); // Default prevent for handled events

        // Parse the rest: "call toggle_like -> #box"
        // This is a very basic parser for the prototype
        const action = this.parseAction(parts.slice(1).join(" "), target);
        if (action) this.execute(action, target);
    }

    parseAction(cmd, element) {
        // Format: "{event} call {action} -> {target} {swap}"
        // or "{event} set {key} = {value}"
        // NOTE: TokenStream adds spaces around punctuation, so "-> #id" becomes "- > # id"

        // Remove extra spaces and reconstruct operators
        // Ensure arrow has spaces around it to be a separate token
        cmd = cmd.replace(/\s*-\s*>\s*/g, " -> ");
        // Ensure ID selector has no internal spaces (e.g. "# myid" -> "#myid")
        cmd = cmd.replace(/#\s+/g, "#");

        const tokens = cmd.split(" ").filter((t) => t.trim() !== "");
        const actionType = tokens[0]; // "call" or "set"

        if (actionType === "call") {
            let actionName = tokens[1]; // The actual action function name
            let url = `/_azumi/action/${actionName}`;
            let targetSelector = null;
            let swap = "morph";

            const arrowIndex = tokens.indexOf("->");
            if (arrowIndex !== -1) {
                targetSelector = tokens[arrowIndex + 1];
                if (tokens[arrowIndex + 2]) {
                    swap = tokens[arrowIndex + 2];
                }
            }

            return {
                type: "call",
                actionName,
                url,
                target: targetSelector,
                swap,
            };
        }

        // TODO: Implement 'set' for local state
        return null;
    }

    // Execute: "call toggle_like -> #box" or "set open = true"
    async execute(action, element) {
        if (action.type === "call") {
            await this.callAction(action, element);
        } else if (action.type === "set") {
            this.setState(action, element);
        }
    }

    /**
     * Azumi Live: Execute optimistic prediction
     */
    executePrediction(scopeElement, prediction) {
        if (!prediction || !scopeElement) return null;

        const scopeAttr = scopeElement.getAttribute("az-scope");
        if (!scopeAttr) return null;

        try {
            const state = JSON.parse(scopeAttr);
            const originalState = JSON.parse(scopeAttr); // Keep copy for rollback

            // Parse multiple predictions separated by ;
            const predictions = prediction
                .split(";")
                .map((p) => p.trim())
                .filter((p) => p);

            for (const pred of predictions) {
                this.applyPrediction(state, pred);
            }

            // Update the scope attribute with new state
            scopeElement.setAttribute("az-scope", JSON.stringify(state));

            // Update any bound elements
            this.updateBindings(scopeElement, state);

            console.log("üöÄ Prediction executed:", prediction, state);

            return { originalState, newState: state };
        } catch (err) {
            console.warn("Prediction execution failed:", err);
            return null;
        }
    }

    applyPrediction(state, pred) {
        // Parse: "field = expr"
        const match = pred.match(/^(\w+)\s*=\s*(.+)$/);
        if (!match) return;

        const [, field, expr] = match;
        const trimmedExpr = expr.trim();

        // Toggle: "!field"
        if (trimmedExpr.startsWith("!")) {
            const toggleField = trimmedExpr.slice(1).trim();
            if (toggleField === field) {
                state[field] = !state[field];
                return;
            }
        }

        // Increment: "field + value"
        const addMatch = trimmedExpr.match(/^(\w+)\s*\+\s*(\d+)$/);
        if (addMatch && addMatch[1] === field) {
            state[field] = (state[field] || 0) + parseInt(addMatch[2], 10);
            return;
        }

        // Decrement: "field - value"
        const subMatch = trimmedExpr.match(/^(\w+)\s*-\s*(\d+)$/);
        if (subMatch && subMatch[1] === field) {
            state[field] = (state[field] || 0) - parseInt(subMatch[2], 10);
            return;
        }

        // Literal assignment
        if (trimmedExpr === "true") {
            state[field] = true;
        } else if (trimmedExpr === "false") {
            state[field] = false;
        } else if (/^-?\d+$/.test(trimmedExpr)) {
            state[field] = parseInt(trimmedExpr, 10);
        } else if (/^-?\d+\.\d+$/.test(trimmedExpr)) {
            state[field] = parseFloat(trimmedExpr);
        } else if (trimmedExpr.startsWith('"') && trimmedExpr.endsWith('"')) {
            state[field] = trimmedExpr.slice(1, -1);
        } else {
            // Fallback: treat as string
            state[field] = trimmedExpr;
        }
    }

    updateBindings(scopeElement, state) {
        const bindings = scopeElement.querySelectorAll("[data-bind]");
        bindings.forEach((el) => {
            const field = el.getAttribute("data-bind");
            if (field && state.hasOwnProperty(field)) {
                el.textContent = state[field];
            }
        });
    }

    rollbackPrediction(scopeElement, originalState) {
        if (!scopeElement || !originalState) return;
        scopeElement.setAttribute("az-scope", JSON.stringify(originalState));
        this.updateBindings(scopeElement, originalState);
        console.log("‚è™ Prediction rolled back");
    }

    // Server action with optimistic prediction
    async callAction(action, element) {
        // Find scope element
        const scopeElement = element.closest("[az-scope]");

        // Check for prediction attribute (Azumi Live)
        const prediction = element.getAttribute("data-predict");
        let predictionResult = null;

        if (prediction && scopeElement) {
            // Execute prediction BEFORE server call (0ms latency!)
            predictionResult = this.executePrediction(scopeElement, prediction);
        }

        // Collect state for server
        let body = null;
        if (element.tagName === "FORM") {
            body = new FormData(element);
            const data = Object.fromEntries(body.entries());
            body = JSON.stringify(data);
        } else {
            if (scopeElement) {
                let scopeData = scopeElement.getAttribute("az-scope");
                body = scopeData || "{}";
            } else {
                body = "{}";
            }
        }

        try {
            const res = await fetch(action.url, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body,
            });

            if (!res.ok) throw new Error(`Action failed: ${res.status}`);

            const html = await res.text();

            // FIXED: Default target to scopeElement (component root), then element
            let target = scopeElement || element;
            if (action.target) {
                target = document.querySelector(action.target);
            }

            if (target && window.Idiomorph) {
                // Morph will reconcile prediction with server truth
                window.Idiomorph.morph(target, html);
            } else if (target) {
                console.warn(
                    "Idiomorph not loaded, falling back to outerHTML replacement"
                );
                target.outerHTML = html;
            }
        } catch (err) {
            console.error("Azumi action error:", err);
            // Rollback prediction on error
            if (predictionResult) {
                this.rollbackPrediction(
                    scopeElement,
                    predictionResult.originalState
                );
            }
        }
    }

    // Local state change
    setState(action, element) {
        console.log("Set state not implemented yet");
    }
}

// Initialize
window.azumi = new Azumi();
console.log("Azumi Live Client Initialized üöÄ");
